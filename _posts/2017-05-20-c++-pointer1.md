---
layout: post
title: C++指针详解二
category: C/C++

---

> [reference](http://www.cnblogs.com/ggjucheng/archive/2011/12/13/2286391.html)

### 六、运算符&和*
这里&是取地址运算符，*是间接运算符。<br/>
&a的运算结果是一个指针，指针的类型是a的类型加个*，指针所指向的类型是a的类型，指针所指向的地址嘛，那就是a的地址。<br/>
*p的结果是p所指向的东西，这个东西有这些特点：它的类型是p指向的类型，它所占用的地址是p所指向的地址。

<pre><code>
	int a=12;  
	int b;  
	int *p;  
	int **ptr;  
	p=&a;//&a的结果是一个指针，类型是int*，指向的类型是int，指向的地址是a的地址。  
	*p=24;//*p的结果，在这里它的类型是int，它所占用的地址是p所指向的地址，显然，*p就是变量a。
	ptr=&p;//&p的结果是个指针，该指针的类型是p的类型加个*，在这里是int**。该指针所指向的类型是p的类型，这里是int*。该指针所指向的地址就是指针p自己的地址。 
	*ptr=&b;//*ptr是个指针，&b的结果也是个指针，且这两个指针的类型和所指向的类型是一样的，所以?amp;b来给*ptr赋值就是毫无问题的了。
	**ptr=34;//*ptr的结果是ptr所指向的东西，在这里是一个指针，对这个指针再做一次*运算，结果就是一个int类型的变量。
</code></pre>

### 指针表达式
一个表达式的最后结果如果是一个指针，那么这个表达式就叫指针表达式。下面是一些指针表达式的例子：  
<pre><code>
int a,b;  
int array[10];  
int *pa;  
pa=&a;//&a是一个指针表达式。  
int **ptr=&pa;//&pa也是一个指针表达式。  
*ptr=&b;//*ptr和&b都是指针表达式。  
pa=array;  
pa++;//这也是指针表达式。
</code></pre>

 
<pre><code>
char *arr[20];  
char **parr=arr;//如果把arr看作指针的话，arr也是指针表达式  
char *str;  
str=*parr;//*parr是指针表达式  
str=*(parr+1);//*(parr+1)是指针表达式  
str=*(parr+2);//*(parr+2)是指针表达式  
</code></pre>
由于指针表达式的结果是一个指针，所以指针表达式也具有指针所具有的四个要素：指针的类型，指针所指向的类型，指针指向的内存区，指针自身占据的内存。

好了，当一个指针表达式的结果指针已经明确地具有了指针自身占据的内存的话，这个指针表达式就是一个左值，否则就不是一个左值。 在例七中，&a不是一个左值，因为它还没有占据明确的内存。*ptr是一个左值，因为*ptr这个指针已经占据了内存，其实*ptr就是指针pa，既然pa已经在内存中有了自己的位置，那么*ptr当然也有了自己的位置。

数组和指针的关系
如果对声明数组的语句不太明白的话，请参阅我前段时间贴出的文章<<如何理解c和c++的复杂类型声明>>。 数组的数组名其实可以看作一个指针。看下例：  

例八：  

int array[10]={0,1,2,3,4,5,6,7,8,9},value;  
...  
...  
value=array[0];//也可写成：value=*array;  
value=array[3];//也可写成：value=*(array+3);  
value=array[4];//也可写成：value=*(array+4);  



上例中，一般而言数组名array代表数组本身，类型是int [10]，但如果把array看做指针的话，它指向数组的第0个单元，类型是int *，所指向的类型是数组单元的类型即int。因此*array等于0就一点也不奇怪了。同理，array+3是一个指向数组第3个单元的指针，所以*(array+3)等于3。其它依此类推。 

例九：  

复制代码
char *str[3]={  
"Hello,this is a sample!",  
"Hi,good morning.",  
"Hello world"  
};  
char s[80]；  
strcpy(s,str[0]);//也可写成strcpy(s,*str);  
strcpy(s,str[1]);//也可写成strcpy(s,*(str+1));  
strcpy(s,str[2]);//也可写成strcpy(s,*(str+2));  
复制代码

上例中，str是一个三单元的数组，该数组的每个单元都是一个指针，这些指针各指向一个字符串。把指针数组名str当作一个指针的话，它指向数组的第0号单元，它的类型是char**，它指向的类型是char *。

*str也是一个指针，它的类型是char*，它所指向的类型是char，它指向的地址是字符串"Hello,this is a sample!"的第一个字符的地址，即'H'的地址。 str+1也是一个指针，它指向数组的第1号单元，它的类型是char**，它指向的类型是char *。 

*(str+1)也是一个指针，它的类型是char*，它所指向的类型是char，它指向"Hi,good morning."的第一个字符'H'，等等。  

下面总结一下数组的数组名的问题。声明了一个数组TYPE array[n]，则数组名称array就有了两重含义：第一，它代表整个数组，它的类型是TYPE [n]；第二，它是一个指针，该指针的类型是TYPE*，该指针指向的类型是TYPE，也就是数组单元的类型，该指针指向的内存区就是数组第0号单元，该指针自己占有单独的内存区，注意它和数组第0号单元占据的内存区是不同的。该指针的值是不能修改的，即类似array++的表达式是错误的。 

在不同的表达式中数组名array可以扮演不同的角色。  

在表达式sizeof(array)中，数组名array代表数组本身，故这时sizeof函数测出的是整个数组的大小。  

在表达式*array中，array扮演的是指针，因此这个表达式的结果就是数组第0号单元的值。sizeof(*array)测出的是数组单元的大小。  

表达式array+n（其中n=0，1，2，....。）中，array扮演的是指针，故array+n的结果是一个指针，它的类型是TYPE*，它指向的类型是TYPE，它指向数组第n号单元。故sizeof(array+n)测出的是指针类型的大小。 

例十：  

int array[10];  
int (*ptr)[10];  
ptr=&array;  

上例中ptr是一个指针，它的类型是int (*)[10]，他指向的类型是int [10]，我们用整个数组的首地址来初始化它。在语句ptr=&array中，array代表数组本身。 

本节中提到了函数sizeof()，那么我来问一问，sizeof(指针名称)测出的究竟是指针自身类型的大小呢还是指针所指向的类型的大小？答案是前者。例如：

int (*ptr)[10];  

则在32位程序中，有：  

sizeof(int(*)[10])==4  
sizeof(int [10])==40  
sizeof(ptr)==4  
实际上，sizeof(对象)测出的都是对象自身的类型的大小，而不是别的什么类型的大小。 　

指针和结构类型的关系
可以声明一个指向结构类型对象的指针。  

例十一：  

按 Ctrl+C 复制代码

struct MyStruct  
{  
int a;  
int b;  
int c;  
}  

MyStruct ss={20,30,40};//声明了结构对象ss，并把ss的三个成员初始化为20，30和40。
MyStruct *ptr=&ss;//声明了一个指向结构对象ss的指针。它的类型是
MyStruct*,它指向的类型是MyStruct。
int *pstr=(int*)&ss;//声明了一个指向结构对象ss的指针。但是它的类型和它指向的类型和ptr是不同的。
按 Ctrl+C 复制代码
请问怎样通过指针ptr来访问ss的三个成员变量？  

答案：  

ptr->a;  
ptr->b;  
ptr->c;  

又请问怎样通过指针pstr来访问ss的三个成员变量？  
答案：  
 

*pstr；//访问了ss的成员a。  
*(pstr+1);//访问了ss的成员b。  
*(pstr+2)//访问了ss的成员c。 

呵呵，虽然我在我的MSVC++6.0上调式过上述代码，但是要知道，这样使用pstr来访问结构成员是不正规的，为了说明为什么不正规，让我们看看怎样通过指针来访问数组的各个单元： 
例十二：  

int array[3]={35,56,37};  
int *pa=array;  
通过指针pa访问数组array的三个单元的方法是：  

*pa;//访问了第0号单元  
*(pa+1);//访问了第1号单元  
*(pa+2);//访问了第2号单元  

从格式上看倒是与通过指针访问结构成员的不正规方法的格式一样。

所有的C/C++编译器在排列数组的单元时，总是把各个数组单元存放在连续的存储区里，单元和单元之间没有空隙。但在存放结构对象的各个成员时，在某种编译环境下，可能会需要字对齐或双字对齐或者是别的什么对齐，需要在相邻两个成员之间加若干个“填充字节”，这就导致各个成员之间可能会有若干个字节的空隙。

所以，在例十二中，即使*pstr访问到了结构对象ss的第一个成员变量a，也不能保证*(pstr+1)就一定能访问到结构成员b。因为成员a和成员b之间可能会有若干填充字节，说不定*(pstr+1)就正好访问到了这些填充字节呢。这也证明了指针的灵活性。要是你的目的就是想看看各个结构成员之间到底有没有填充字节，嘿，这倒是个不错的方法。 

通过指针访问结构成员的正确方法应该是象例十二中使用指针ptr的方法。

指针和函数的关系
可以把一个指针声明成为一个指向函数的指针。  

int fun1(char*,int);  
int (*pfun1)(char*,int);  
pfun1=fun1;  
....  
....  
int a=(*pfun1)("abcdefg",7);//通过函数指针调用函数。  
可以把指针作为函数的形参。在函数调用语句中，可以用指针表达式来作为实参。  
1. hkhk  
2. kjk  
3. hgf  
 
* gfhgf  
* hnh  

[x] hgfhgj  
[ ] hgjgh  
[x]  jkhhjj