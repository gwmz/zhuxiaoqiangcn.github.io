---
layout: post
title: C++指针详解一
category: C/C++

---

> [reference](http://www.cnblogs.com/ggjucheng/archive/2011/12/13/2286391.html)



### 零、指针的概念
指针是一个特殊的变量，它里面存储的值被解释成为内存里的一个地址。<br/>
要搞清一个指针需要搞清指针的四方面的内容：**指针的类型，指针本身所占据的内存区，指针的值或者叫指针所指向的内存区，指针所指向的类型**。 	


### 一、指针的类型
从语法的角度看，只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针本身所具有的类型。
<pre>
<code>
	int *ptr; //指针的类型是int *  
	char *ptr; //指针的类型是char *  
	int **ptr; //指针的类型是 int **  
	int (*ptr)[3]; //指针的类型是 int(*)[3]  
	int *(*ptr)[4]; //指针的类型是 int *(*)[4]
</code>
</pre>


### 二、指针本身所占据的内存区
指针本身占了多大的内存？你只要用函数sizeof(指针的类型)测一下就知道了。<br/>
**在32位平台里，指针本身占据了4个字节的长度。**<br/>
指针本身占据的内存这个概念在判断一个指针表达式是否是 左值 时很有用。


### 三、指针的值			   	 
指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个普通的数值。<br/>
在32位程序里，所有类型的指针的值都是一个32位整数，因为32位程序里内存地址全都是32位长。<br/>
指针所指向的内存区就是**从指针的值所代表的那个内存地址开始，长度为sizeof(指针所指向的类型)的一片内存区。**<br/>
我们说一个指针的值是XX，就相当于说该指针指向了以XX为首地址的一片内存区域；<br/>
我们说一个指针指向了某块内存区域，就相当于说该指针的值是这块内存区域的首地址。


### 四、指针所指向的类型
当你通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。<br/>
从语法上看，只须把指针声明语句中的指针名字和名字左边的指针声明符'*' 去掉，剩下的就是指针所指向的类型。
<pre>
<code>
	int *ptr; //指针所指向的类型是int  
	char *ptr; //指针所指向的的类型是char  
	int **ptr; //指针所指向的的类型是 int *  
	int (*ptr)[3]; //指针所指向的的类型是 int()[3]  
	int *(*ptr)[4]; //指针所指向的的类型是 int *()[4]
</code>
</pre>


### 五、指针的算术运算
指针可以加上或减去一个整数。<br/>
指针的这种运算的意义和通常的数值的加减运算的意义是不一样的。<br/>
<一><br/>
指针ptr的类型是int*,它指向的类型是int，它被初始化为指向整形变量a。<br/>
指针ptr被加了1，编译器是这样处理的：它把指针ptr的值加上了sizeof(int)，在32位程序中，是被加上了4。<br/>
由于地址是用字节做单位的，故ptr所指向的地址由原来的变量a的地址向高地址方向增加了4个字节。<br/>
由于char类型的长度是一个字节，所以原来ptr是指向数组a的第0号单元开始的四个字节，此时指向了数组a中从第4号单元开始的四个字节。
<pre><code>
	char a[20];  
	int *ptr=a;  
	...   
	ptr++;  
</code></pre>

<二><br/>
我们可以用一个指针和一个循环来遍历一个数组。<br/>
这个例子将整型数组中各个单元的值加1。由于每次循环都将指针ptr加1，所以每次循环都能访问数组的下一个单元。
<pre><code>
	int array[20];  
	int *ptr=array;  
	...  
	//此处略去为整型数组赋值的代码。  
	...  
	for(i=0;i<20;i++)  
	{  
		(*ptr)++;  
		ptr++；  
	}   
</code></pre> 

<三><br/>
在这个例子中，ptr被加上了5 <br/>
**编译器是这样处理的：**将指针ptr的值加上5乘sizeof(int)，在32位程序中就是加上了5乘4=20。<br/>
由于地址的单位是字节，故现在的ptr所指向的地址比起加5后的ptr所指向的地址来说，向高地址方向移动了20个字节。<br/>
在这个例子中，没加5前的ptr指向数组a的第0号单元开始的四个字节，加5后，ptr已经指向了数组a的合法范围之外了。<br/>
虽然这种情况在应用上会出问题，但在语法上却是可以的，这也体现出了指针的灵活性。<br/>
如果，ptr是被减去5，那么处理过程大同小异，只不过ptr的值是被减去5乘sizeof(int)，新的ptr指向的地址将比原来的ptr所指向的地址向低地址方向移动了20个字节。<br/>
**总结一下**<br/>
一个指针ptrold加上一个整数n后，结果是一个新的指针ptrnew，ptrnew的类型和ptrold的类型相同，ptrnew所指向的类型和ptrold所指向的类型也相同。ptrnew的值将比ptrold的值增加了n乘sizeof(ptrold所指向的类型)个字节。就是说，ptrnew所指向的内存区将比ptrold所指向的内存区向高地址方向移动了n乘sizeof(ptrold所指向的类型)个字节。一个指针ptrold减去一个整数n后，结果是一个新的指针ptrnew，ptrnew的类型和ptrold的类型相同，ptrnew所指向的类型和ptrold所指向的类型也相同。ptrnew的值将比ptrold的值减少了n乘sizeof(ptrold所指向的类型)个字节，就是说，ptrnew所指向的内存区将比ptrold所指向的内存区向低地址方向移动了n乘sizeof(ptrold所指向的类型)个字节。<br/>
<pre><code>
	char a[20];  
	int *ptr = a;  
	...  
	...  
	ptr += 5; 
</code></pre>  


### 六、fvf
