---
layout: post
title: 浅析C语言swap函数
category: C

---

> [reference](http://blog.csdn.net/zhupananhui/article/details/16939035)

### 1.try to swap the value of a and b, but it does not work out. 
```C
void swap1(int a,int b) 
{ 
    int temp; 
    temp = a; 
    a = b; 
    b = temp; 
}
```


### 2.using the global variables can implement the swap.
```C
int a(3),b(5);
void swap2() 
{ 
    int temp; 
    temp = a; 
    a = b; 
    b = temp; 
}
```
### 3.using the pointer to pass the address to the swap function.
```C
void swap3(int *px,int *py) 
{ 
    int temp; 
    temp = *px; 
    *px = *py; 
    *py = temp; 
}
```
### 4.using the reference operator(&). 
```C
void swap1(int &a, int &b) 
{ 
    int temp; 
    temp = a; 
    a = b; 
    b = temp; 
}
```
### 5.meaningless swap. 
```C
void swap5(int *px,int *py) 
{ 
    int *p; 
    p = px; 
    px = py; 
    px = p; 
}
```
### 7.Description
swap1只进行了值传递，所以函数调用结束后形参被释放，不能实现实参的值交换；  
swap2直接使用全局变量，这样swap2函数和main函数操作的是同一个变量（地址和值都一样），可以实现值交换；  
swap3使用传地址的方式，通过修改内存块来实现变量的值交换，是可以的。  
swap4使用引用（&）的方式，这样是给mian函数中待交换的变量起一个别名，并把把别名作为形参在swap4中进行处理，这其实就实现了形参和实参的地址和内容完全一样，当然可以实现值交换，swap4的效果和swap2的一样，但这种定义方式更利于程序的调试和维护，同时也可以减小内存开销。  
swap5中虽然也把变量的地址传到了函数中，但在函数内部并没用修改地址指向的内存块而是把地址在形参上完成交换，swap5函数运行结束，所有的工作都会都是，而main函数中的变量也没有实现交换，这种情况和swap1类似。  